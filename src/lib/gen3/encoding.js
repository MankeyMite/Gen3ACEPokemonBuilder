// src/lib/gen3/encoding.js
// Gen 3 Western character encoding (English Emerald / FRLG / RS).
// This table is based on the Bulbapedia “Character encoding (Generation III)”
// Western charset. It covers the characters you’re realistically going to need
// for nicknames and OT names (A–Z, a–z, digits, punctuation, gender symbols,
// and common accented letters).

export const CHAR_TABLE = {
  // Space / padding
  ' ': 0x00, // in fixed-length fields, 0x00 also serves as padding

  // Digits (row A-)
  '0': 0xA1,
  '1': 0xA2,
  '2': 0xA3,
  '3': 0xA4,
  '4': 0xA5,
  '5': 0xA6,
  '6': 0xA7,
  '7': 0xA8,
  '8': 0xA9,
  '9': 0xAA,

  // Basic punctuation / symbols
  '!': 0xAB,
  '?': 0xAC,
  '.': 0xAD,
  '-': 0xAE,
  '…': 0xB0,      // ellipsis (prints as …/‥ depending on context)
  '\'': 0xB4,     // apostrophe (right single quote in the table)
  ',': 0xB8,
  '/': 0xBA,
  ':': 0xF0,

  // Gender symbols
  '♂': 0xB5,
  '♀': 0xB6,

  // Uppercase letters A–Z
  'A': 0xBB,
  'B': 0xBC,
  'C': 0xBD,
  'D': 0xBE,
  'E': 0xBF,
  'F': 0xC0,
  'G': 0xC1,
  'H': 0xC2,
  'I': 0xC3,
  'J': 0xC4,
  'K': 0xC5,
  'L': 0xC6,
  'M': 0xC7,
  'N': 0xC8,
  'O': 0xC9,
  'P': 0xCA,
  'Q': 0xCB,
  'R': 0xCC,
  'S': 0xCD,
  'T': 0xCE,
  'U': 0xCF,
  'V': 0xD0,
  'W': 0xD1,
  'X': 0xD2,
  'Y': 0xD3,
  'Z': 0xD4,

  // Lowercase letters a–z
  'a': 0xD5,
  'b': 0xD6,
  'c': 0xD7,
  'd': 0xD8,
  'e': 0xD9,
  'f': 0xDA,
  'g': 0xDB,
  'h': 0xDC,
  'i': 0xDD,
  'j': 0xDE,
  'k': 0xDF,
  'l': 0xE0,
  'm': 0xE1,
  'n': 0xE2,
  'o': 0xE3,
  'p': 0xE4,
  'q': 0xE5,
  'r': 0xE6,
  's': 0xE7,
  't': 0xE8,
  'u': 0xE9,
  'v': 0xEA,
  'w': 0xEB,
  'x': 0xEC,
  'y': 0xED,
  'z': 0xEE,

  // Common accented letters from rows 0- and 1-
  'À': 0x80,
  'Á': 0x81,
  'Â': 0x82,
  'Ç': 0x83,
  'È': 0x84,
  'É': 0x85,
  'Ê': 0x86,
  'Ë': 0x87,
  'Ì': 0x88,
  'Î': 0x89,
  'Ï': 0x8A,
  'Ò': 0x8B,
  'Ó': 0x8C,
  'Ô': 0x8D,

  'Œ': 0x90,
  'Ù': 0x91,
  'Ú': 0x92,
  'Û': 0x93,
  'Ñ': 0x94,
  'ß': 0x95,
  'à': 0x96,
  'á': 0x97,
  'ç': 0x98,
  'è': 0x99,
  'é': 0x9A,
  'ê': 0x9B,
  'ë': 0x9C,
  'ì': 0x9D,

  // Row 2- (only the ones you’re likely to ever see)
  'î': 0xA0,
  'ï': 0xA1,  // note: clashes with '0' if interpreted differently; use with care
  'ò': 0xA2,
  'ó': 0xA3,
  'ô': 0xA4,
  'œ': 0xA5,
  'ù': 0xA6,
  'ú': 0xA7,
  'û': 0xA8,
  'ñ': 0xA9,

  // Fullwidth characters (used in Japanese character set decoding)
  // These map to the same byte values as their regular ASCII equivalents
  '　': 0x00,  // Fullwidth space
  '０': 0xA1, '１': 0xA2, '２': 0xA3, '３': 0xA4, '４': 0xA5,
  '５': 0xA6, '６': 0xA7, '７': 0xA8, '８': 0xA9, '９': 0xAA,
  '！': 0xAB,
  '？': 0xAC,
  '。': 0xAD,  // Japanese period (maps to '.')
  'ー': 0xAE,  // Japanese prolonged sound mark (maps to '-')
  'Ａ': 0xBB, 'Ｂ': 0xBC, 'Ｃ': 0xBD, 'Ｄ': 0xBE, 'Ｅ': 0xBF,
  'Ｆ': 0xC0, 'Ｇ': 0xC1, 'Ｈ': 0xC2, 'Ｉ': 0xC3, 'Ｊ': 0xC4,
  'Ｋ': 0xC5, 'Ｌ': 0xC6, 'Ｍ': 0xC7, 'Ｎ': 0xC8, 'Ｏ': 0xC9,
  'Ｐ': 0xCA, 'Ｑ': 0xCB, 'Ｒ': 0xCC, 'Ｓ': 0xCD, 'Ｔ': 0xCE,
  'Ｕ': 0xCF, 'Ｖ': 0xD0, 'Ｗ': 0xD1, 'Ｘ': 0xD2, 'Ｙ': 0xD3,
  'Ｚ': 0xD4,
  'ａ': 0xD5, 'ｂ': 0xD6, 'ｃ': 0xD7, 'ｄ': 0xD8, 'ｅ': 0xD9,
  'ｆ': 0xDA, 'ｇ': 0xDB, 'ｈ': 0xDC, 'ｉ': 0xDD, 'ｊ': 0xDE,
  'ｋ': 0xDF, 'ｌ': 0xE0, 'ｍ': 0xE1, 'ｎ': 0xE2, 'ｏ': 0xE3,
  'ｐ': 0xE4, 'ｑ': 0xE5, 'ｒ': 0xE6, 'ｓ': 0xE7, 'ｔ': 0xE8,
  'ｕ': 0xE9, 'ｖ': 0xEA, 'ｗ': 0xEB, 'ｘ': 0xEC, 'ｙ': 0xED,
  'ｚ': 0xEE,

  // Japanese Hiragana
  'あ': 0x01, 'い': 0x02, 'う': 0x03, 'え': 0x04, 'お': 0x05,
  'か': 0x06, 'き': 0x07, 'く': 0x08, 'け': 0x09, 'こ': 0x0A,
  'さ': 0x0B, 'し': 0x0C, 'す': 0x0D, 'せ': 0x0E, 'そ': 0x0F,
  'た': 0x10, 'ち': 0x11, 'つ': 0x12, 'て': 0x13, 'と': 0x14,
  'な': 0x15, 'に': 0x16, 'ぬ': 0x17, 'ね': 0x18, 'の': 0x19,
  'は': 0x1A, 'ひ': 0x1B, 'ふ': 0x1C, 'へ': 0x1D, 'ほ': 0x1E,
  'ま': 0x1F, 'み': 0x20, 'む': 0x21, 'め': 0x22, 'も': 0x23,
  'や': 0x24, 'ゆ': 0x25, 'よ': 0x26,
  'ら': 0x27, 'り': 0x28, 'る': 0x29, 'れ': 0x2A, 'ろ': 0x2B,
  'わ': 0x2C, 'を': 0x2D, 'ん': 0x2E,
  'ぁ': 0x2F, 'ぃ': 0x30, 'ぅ': 0x31, 'ぇ': 0x32, 'ぉ': 0x33,
  'ゃ': 0x34, 'ゅ': 0x35, 'ょ': 0x36,
  'が': 0x37, 'ぎ': 0x38, 'ぐ': 0x39, 'げ': 0x3A, 'ご': 0x3B,
  'ざ': 0x3C, 'じ': 0x3D, 'ず': 0x3E, 'ぜ': 0x3F, 'ぞ': 0x40,
  'だ': 0x41, 'ぢ': 0x42, 'づ': 0x43, 'で': 0x44, 'ど': 0x45,
  'ば': 0x46, 'び': 0x47, 'ぶ': 0x48, 'べ': 0x49, 'ぼ': 0x4A,
  'ぱ': 0x4B, 'ぴ': 0x4C, 'ぷ': 0x4D, 'ぺ': 0x4E, 'ぽ': 0x4F,
  'っ': 0x50,

  // Japanese Katakana
  'ア': 0x51, 'イ': 0x52, 'ウ': 0x53, 'エ': 0x54, 'オ': 0x55,
  'カ': 0x56, 'キ': 0x57, 'ク': 0x58, 'ケ': 0x59, 'コ': 0x5A,
  'サ': 0x5B, 'シ': 0x5C, 'ス': 0x5D, 'セ': 0x5E, 'ソ': 0x5F,
  'タ': 0x60, 'チ': 0x61, 'ツ': 0x62, 'テ': 0x63, 'ト': 0x64,
  'ナ': 0x65, 'ニ': 0x66, 'ヌ': 0x67, 'ネ': 0x68, 'ノ': 0x69,
  'ハ': 0x6A, 'ヒ': 0x6B, 'フ': 0x6C, 'ヘ': 0x6D, 'ホ': 0x6E,
  'マ': 0x6F, 'ミ': 0x70, 'ム': 0x71, 'メ': 0x72, 'モ': 0x73,
  'ヤ': 0x74, 'ユ': 0x75, 'ヨ': 0x76,
  'ラ': 0x77, 'リ': 0x78, 'ル': 0x79, 'レ': 0x7A, 'ロ': 0x7B,
  'ワ': 0x7C, 'ヲ': 0x7D, 'ン': 0x7E,
  'ァ': 0x7F, 'ィ': 0x80, 'ゥ': 0x81, 'ェ': 0x82, 'ォ': 0x83,
  'ャ': 0x84, 'ュ': 0x85, 'ョ': 0x86,
  'ガ': 0x87, 'ギ': 0x88, 'グ': 0x89, 'ゲ': 0x8A, 'ゴ': 0x8B,
  'ザ': 0x8C, 'ジ': 0x8D, 'ズ': 0x8E, 'ゼ': 0x8F, 'ゾ': 0x90,
  'ダ': 0x91, 'ヂ': 0x92, 'ヅ': 0x93, 'デ': 0x94, 'ド': 0x95,
  'バ': 0x96, 'ビ': 0x97, 'ブ': 0x98, 'ベ': 0x99, 'ボ': 0x9A,
  'パ': 0x9B, 'ピ': 0x9C, 'プ': 0x9D, 'ペ': 0x9E, 'ポ': 0x9F,
  'ッ': 0xA0
};

// Generic encoder for nicknames / OT names.
// - str: JS string
// - maxLen: max bytes (10 for nickname, 7 for OT)
// Output: Uint8Array(maxLen), filled with 0xFF padding.
// Gen 3 uses 0xFF as string terminator; bytes after the first 0xFF are ignored.
export function encodeName(str, maxLen) {
  const capped = (str ?? '').slice(0, maxLen);

  // Start with 0xFF padding (terminator + ignored bytes)
  const bytes = new Uint8Array(maxLen).fill(0xFF);

  // Encode each character
  for (let i = 0; i < capped.length; i++) {
    const ch = capped[i];
    const mapped = CHAR_TABLE[ch];

    if (mapped !== undefined) {
      bytes[i] = mapped;
    } else {
      // Fallback to space character for unknown chars
      bytes[i] = 0x00;
    }
  }

  // 0xFF terminator is already in place from the fill() above
  // (bytes after the string are already 0xFF, which acts as terminator)

  return bytes;
}

// Convenience helpers so the builder doesn’t have to remember lengths.
export const encodeNickname = (name) => encodeName(name, 10);
export const encodeOT       = (name) => encodeName(name, 7);
